---
title: "UnityでぼくのかんがえたさいきょうのMVPアーキテクチャを実装して考察してみた話"
emoji: "🍖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["unity", "csharp", "architecture"]
published: false
---

# はじめに

## 本記事の内容

本記事では Unity における GUI 周りの実装で用いられる MVP アーキテクチャパターンについての内容を扱います。MVP アーキテクチャについて調べている中で筆者が疑問に思ったことをきっかけに、解決策を考えて実装し、最後にそれについて考察してみました。本記事はその過程を共有するというものです。

ところでタイトルにもある「ぼくのかんがえたさいきょうの～～」とは「設定をモリモリにしすぎた結果強さがインフレした」状態に使われるミームの一種です。本記事で登場する実装もまさに「もっとこうしたら強くなれるんじゃないか」を実践した結果生まれたオーバーエンジニアリング気味の実装について「作ってみたはいいものの......どうなの......」となった話を記事化しました。ぜひ友人の小噺を聞く感じで肩の力を抜いて読んでいただければ幸いです。

## 注意

本記事は MVP アーキテクチャの実装の提案をするもの**ではありません。**
趣旨としては「筆者が疑問に思ったことを検証した過程とその間に考えたことをつづる」というものです。後述しますが、ここで考えた実装は一部の状況でのみ有効なのではという感想を筆者はもちました。あくまでここに書いてあることは事実と筆者の感想ですので、そのあとの判断・解釈・評価は皆様にお任せいたします。

しかし事実として間違った説明が含まれている可能性があります。その際には優しくご指摘いただけると幸いです（筆者は大規模アーキテクチャに関する経験がほぼないので、ぜひ温かい目で見守っていただけると嬉しいです）。

## 対象読者

- Unity の基礎知識がある
- C#言語のの基礎知識がある
- MVP アーキテクチャの概要がわかっている

本記事では説明なしに UniRx・DI フレームワークなどの技術スタックを扱いますのでそれらの知識があることと良いです。

## 検証環境とサンプルプロジェクト

今回の試行に際してサンプルプロジェクトをご用意しました。記事内でも触れることがあります。

https://github.com/drumath2237/DI-Used-Pure-MVP-testbed

サンプルプロジェクトで使用した（つまり本記事で前提となる）環境は次の通りです。

| 環境       |                                  |
| :--------- | :------------------------------- |
| Unity      | 2021.3.4f1                       |
| 開発機     | Windows 10 Home・Windows 11 Home |
| UniRx      | 7.1.0                            |
| VContainer | 1.12.0                           |

# n番煎じの疑問

## UnityにおけるMVPアーキテクチャ

Unity において GUI のロジックを実装する時によく使われる MVP アーキテクチャというアーキテクチャパターンがあります。「Unity MVP」と検索すると多数の日本語文献が見つかりますよね。
その中には具体的な実装も載せてくれている記事があり、そのおかげで筆者も MVP を勉強する際は独学で何とか習得できました。時には何度か記事で紹介してあったやり方で UI を組んでみたり、自分なりにアレンジして使ってみたりもしました。また最近は CyberAgent さんが開催された[Game Client College～設計編～](https://www.cyberagent.co.jp/careers/students/event/detail/id=27819)に参加して、MVP アーキテクチャを用いたゲーム開発について学びました。
MVP の実装パターンが何となく見えてきたところで前から思っていた疑問が頭をよぎりました。「なんで Presenter が非 MonoBehaviour じゃないんだろう......」。

## Presenterを非MonoBehaviourにしたい

私が目にした多くのサンプルで MVP の実装では Presneter と View、または MVP すべてが MonoBehaviour を継承したクラスを作っていました。次に示す記事でもそうですし、Game Client College でもそうでした。

https://qiita.com/toRisouP/items/5365936fc14c7e7eabf9#presenter%E3%81%AE%E5%AE%9F%E8%A3%85%E6%96%B9%E6%B3%95

https://virtualcast.jp/blog/2019/11/mvp_pattern_on_unity/

https://takap-tech.com/entry/2021/11/27/195909

https://light11.hatenadiary.com/entry/2019/01/23/231828#Presenter%E3%81%AFMonoBehaviour%E3%81%AB%E3%81%99%E3%82%8B%E3%81%B9%E3%81%8D

ただ Presenter は Model と View をつなぐ役割が基本であるため、 Unity フレームワークの機能を多く使う部分ではないはずです。ゆえに以前から筆者は「MonoBehaviour じゃなくていいのでは」と思っていました。

:::message
上記の記事の中にはすでにPresenterがなぜMonoBehaviourクラスになっているのかを説明されているものがあります。
:::

人によってここに対する疑問は変わってくるのではないかと考えます。筆者の場合は「MonoBehaviour が不必要な場面で使うのはどうなんだろう」という思考をすることが多かったためそういう疑問の持ち方をしました。それは MonoBehaviour を使うことで生まれるデメリットがあるからです。

## MonoBehaviourの問題点

Unity の Prefab システムはとても手軽で便利です。加えて SerializeField を使えばインスペクタで依存関係を解決できるので直感的です。
しかし Prefab の乱用は簡単にアナーキーな循環参照を生み出しますし、依存関係をコードベースで追うのが難しくもなります。[Gotanda.unity #18で登壇された吉谷さんの言葉](https://youtu.be/b-BNPYQ5VG0?t=340)を借りると「MonoBehaviour は Easy だけど複雑」です。特に複数人で長期的に運用する Unity プロジェクトで好き勝手使うと、機能追加や変更の際のコスト増加につながります。

そして MonoBehaviour クラスの特殊な点として、new によるインスタンス化ができない（コンストラクタが使えない）があります。コンストラクタは C#言語の強力な機能です。コンストラクタがあるおかげで開発者はインスタンスの生成を管理でき、コンストラクタによって依存関係を明確化・初期化できます。
new が使えないデメリットとして良く挙げられるのはユニットテストでしょうか。ユニットテストは Unity コンテキストで行われないため明示的にコンストラクタを呼んでインスタンス化する必要がありますが、MonoBehaviour クラスではそれができません（実は何か解決策があるのでしょうか）。また、コンストラクタの引数で依存を指定できれば、インタフェースで抽象化してテスト用と本番用で差し替えることも可能です。これらの使い方が MonoBehaviour を使うことで封じられてしまうので、テストが必要なコアロジックは Pure C#に分離するようなテクニックを使うこともあります。

## MVPアーキテクチャとMonoBehaviour

MonoBehaviour は手軽だが C#言語の持つ強力な機能を封じてしまうデメリットがあることを述べました。ではなぜ、よく見る MVP アーキテクチャの実装例では Presenter や Model までもが MonoBehaviour を継承したクラスで実装されていることが多いのでしょうか。実はすでに「Presenter を非 MonoBehaviour にしたい」で挙げた記事の中にはその回答をしていただいているものがあります。しかもこれは、すでに大勢の先人たちが抱いてきた「n 番煎じの疑問」なのです。ここで Unity における設計や UniRx・UniTask についての文献を多数執筆なさっているとりすーぷさんが記事内で書かれている回答を引用します。

>MV(R)Pパターンは「MonoBehaviourの有無について語っていません」。
>
>MonoBehaviourはすべてのオブジェクトで使ってもいいですし使わなくてもいいです。つまり、どっちでもいいです。
>たまに「ModelはUnity非依存にするべき」とか語っている人がいますが、そんなことはないです。
> [『【Unity】Model-View-(Reactive)Presenterパターンとは何なのか』](https://qiita.com/toRisouP/items/5365936fc14c7e7eabf9#mvrp%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A3%E3%81%A6monobehaviour%E3%81%AF%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%84%E3%81%84%E3%82%93%E3%81%A7%E3%81%99%E3%81%8B)より

今では筆者もこちらの回答に同意で、記事を拝見したときにこの言語化を受けてすっきり納得できました。時系列的には筆者がこの記事を拝見する前に本記事で扱う試行をしていたため、より納得できた感じがしています。ということで、ここから後の内容は筆者がまだしっかりした回答を得ていない頃であるという前提で読んでいただきたいです。

# さいきょうのMVPアーキテクチャを実装する

## サンプルプロジェクトの概要

それでは「Presenter を MonoBehaviour にできないか」を検証するために簡単な GUI 処理を MVP アーキテクチャで設計・実装していきます。サンプルとしてありがちですが、体力ゲージの値の更新と表示をする実装をしてみます。最終的に次の動画のようになりました。

https://www.youtube.com/watch?v=y8PNM8C7Ck8

## クラス構成

## 依存性注入

# 考察する

## Presenterのテスタビリティ

## そもそもPresenterのテストは必要なのか

## さいきょうのMVPアーキテクチャはさいきょうなのか

# おわりに

## 謝辞

## 参考文献
