---
title: "Vite環境のBabylon.jsでシェーダを読み込むtips"
emoji: "🍱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["babylonjs", "shader", "webgl", "vite", "typescript"]
published: false
---

# はじめに

この記事は[Babylon.js アドベントカレンダー 2022](https://qiita.com/advent-calendar/2022/babylonjs)の 11 日目の記事です。

## TL;DR

Vite では`?raw`サフィックスを使うことでアセットを文字列としてインポートできるので、それを ShaderMaterial に渡すことでシェーダをインポートできる。

## 本記事の概要と対象読者

本記事では Vite ＋ TypeScript で環境構築した Babylon.js プロジェクトでシェーダをインポートする方法をご紹介する内容になっています。
とても軽い内容で半分筆者の備忘録的な感じですが、お付き合いいただけると嬉しいです。

本記事では Babylon.js や TypeScript・Vite・シェーダに関する初歩的な説明をしませんので、
お読みになる際にはこれらの技術スタックについて知っていることが望ましいです。
しかしそこまで難しい内容を扱うわけではないので、どうぞお気軽にご覧ください。

## 検証環境

検証環境は次の通りです。

| 環境            | バージョン |
| :-------------- | :--------- |
| Node.js         | v16.18.0   |
| TypeScript      | v4.6.4     |
| vite            | v3.2.3     |
| @babylonjs/core | v5.34.0    |

## サンプルプロジェクト

GitHub にてサンプルプロジェクトを公開しておりますので、そちらも合わせてご覧になってください。
https://github.com/drumath2237/babylon-shader-import-sample

デモも見られます。
https://drumath2237.github.io/babylon-shader-import-sample/

# シェーダの読み込み

## 読み込み方法の選択肢

Babylon.js ではシェーダの読み込み方法が何通りかあり、下記 docs ページに列挙されています。この中で紹介されている方法を軽く紹介します（どれも今回紹介する方法ではありません）。

https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderCodeInBjs

### CYOS からダウンロードする方法

Babylon.js では CYOS というシェーダ版 Playground みたいなツールがあり、それを使うことでプレビューを見ながら Vertex シェーダと Fragment シェーダを書いていくことが可能です。
https://cyos.babylonjs.com/#8U2ERV#1
また CYOS は編集したシェーダコードをダウンロードできます。
プレビュー用のテクスチャファイルと HTML ファイル 1 つが.zip で固められたものがダウンロードされます。
それを解凍して HTML のなかにインラインで記述されたシェーダコード部分を流用すればシェーダのインポートができますね。
しかしこの方法、なかなか手間です。ローカルプロジェクトへシェーダを反映するイテレーションがかなり回しにくそうなので個人的にあまり好みではありません。

### script タグのなかに書く

HTML のスクリプトタグにシェーダコードを記述して、それを Babylon.js で参照するという仕組みがあります。
以下は docs に載っているサンプルコードの引用です。

:::details script タグからシェーダをインポートするサンプルコード

```html:scriptタグの中に書かれたシェーダコード
<script type="application/vertexShader" id="vertexShaderCode">
    #ifdef GL_ES
        precision highp float;
    #endif

    // Attributes
    attribute vec3 position;
    attribute vec2 uv;

    // Uniforms
    uniform mat4 worldViewProjection;

    // Normal
    varying vec2 vUV;

    void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
    }
</script>

<script type="application/fragmentShader" id="fragmentShaderCode">
    #ifdef GL_ES
        precision mediump float;
    #endif

    varying vec2 vUV;

    uniform sampler2D textureSampler;

    void main(void) {
        gl_FragColor = texture2D(textureSampler, vUV);
    }
</script>
```

```js:タグに書かれたシェーダをインポートするコード
var shaderMaterial = new BABYLON.ShaderMaterial(
  "shader",
  scene,
  {
    vertexElement: "vertexShaderCode",
    fragmentElement: "fragmentShaderCode",
  },
  {
    attributes: ["position", "normal", "uv"],
    uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"],
  },
);
```

:::

HTML の中で js コードも記述しているような場合は便利そうです。
しかし今回想定しているような Vite ＋ TypeScript な構成でこれをやると、
ロジックとビューでちゃんとファイル分けされているのにわざわざ HTML のコードも編集しなくちゃいけなくなるのはちょっと嫌ですね......。

### `.fx`ファイルからインポートする

次のような条件を満たすことで Babylon.js が良しなにシェーダデータをフェッチしてインポートしてくれます。

- HTML ファイルとシェーダファイルが同じディレクトリにある
- Vertex シェーダファイルの名前は`xxx.vertex.fx`というフォーマット
- Fragment シェーダファイルの名前は`xxx.fragment.fx`というフォーマット

この条件を満たしたうえで次のようなコードによってシェーダファイルをインポートできます。

```js
var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, "./xxx", {
  attributes: ["position", "normal", "uv"],
  uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"],
});
```

一見スマートそうですが、ディレクトリ構成の制約が少し汚く感じました。
特にバンドラや JS フレームワークと一緒に使う場合には追加の設定が必要になる可能性があります。

## Vite の静的アセットの取り扱い

## `?raw`を使って読み込む

# おわりに

## 参考文献

https://ja.vitejs.dev/guide/assets.html

https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderCodeInBjs
